<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    *{
        margin: 0;
        padding: 0;
    }
    div{
        font-family: 'Courier New', Courier, monospace;
    }
    button{
        width: 100px;
        height: 60px;
        
    }
</style>
<body>
    <button id="opencom" onclick="openble()">打开串口</button>
    <button id="opencom" onclick="testswd()">测试SWD</button>
    <div contenteditable="true" id="output"></div>
</body>
<script>
    class DataHelper{
        constructor(val=null){
            this.data=val?val:[];
            this.rpos=0;
            this.LE=true;
        }
        w32(v){
            if(this.LE){
                this.data.push((v>>0)&0xff);
                this.data.push((v>>8)&0xff);
                this.data.push((v>>16)&0xff);
                this.data.push((v>>24)&0xff);
            }
            else{
                this.data.push((v>>24)&0xff);
                this.data.push((v>>16)&0xff);
                this.data.push((v>>8)&0xff);
                this.data.push((v>>0)&0xff);
            }
            return this;
        }
        w16(v){
            if(this.LE){
                this.data.push((v>>0)&0xff);
                this.data.push((v>>8)&0xff);
            }
            else{
                this.data.push((v>>8)&0xff);
                this.data.push((v>>0)&0xff);
            }
            return this;
        }
        w8(v){
            this.data.push(v&0xff);
            return this;
        }
        align(pos){
            while(this.data.length<pos)this.data.push(0);
            return this;
        }
        wbuff(buff){
            buff.forEach(e=>this.data.push(e));
            return this;
        }

        bytes(){
            return this.data;
        }


        r8(){
            return this.data[this.rpos++];
        }
        r16(){
            let v=0;
            if(this.LE){
                v=this.data[this.rpos++];
                v|=this.data[this.rpos++]<<8;
            }
            else{
                v=this.data[this.rpos++]<<8;
                v|=this.data[this.rpos++];
            }
            return v;
        }
        r32(){
            let v=0;
            if(this.LE){
                v=this.data[this.rpos++];
                v|=this.data[this.rpos++]<<8;
                v|=this.data[this.rpos++]<<16;
                v|=this.data[this.rpos++]<<24;
            }
            else{
                v=this.data[this.rpos++]<<24;
                v|=this.data[this.rpos++]<<16;
                v|=this.data[this.rpos++]<<8;
                v|=this.data[this.rpos++];
            }
            return v;
        }
        rbuff(len){
            let v=[];
            while(len--)v.push(this.data[this.rpos++]);
            return v;
        }
        rappend(v,len){
            while(len--)v.push(this.data[this.rpos++]);
            return v;
        }
        rskip(len){
            this.rpos+=len;
            return this;
        }
        
    }
</script>
<script>
    class BLEUART{
        constructor(statschange=null,onrecvdata,filters=0xfff0,readservice=0xfff1,writeservice=0xfff2){
            if(!('bluetooth' in navigator))return;
            this.OnstatusChange=statschange?statschange:()=>{};
            this.OnReceiveData=onrecvdata?onrecvdata:()=>{};
            
            this.Sender=null;
            this.deviceName='';
            this.device=null;
            this.connected=false;
            this.Service=null;
            this.buffer=[];
            this.logs=[];
            this.filters=filters;
            this.readservice=readservice;
            this.writeservice=writeservice;

            this.rxFollowTx=true;
            this.rxReqCount=1;
            this.rxPromise=null;
            this.rxPromiseresolve=null;
            this.rxPromisereject=null;
            this.rxPromisecallback=null;
            this.timer=setInterval(() => {
                if(this.buffer.length>=this.rxReqCount)
                {
                    //this.OnReceiveData(this.buffer);
                    if(this.rxPromise){
                        if(this.buffer.length>=this.rxReqCount){
                            const buff=this.buffer.splice(0,this.rxReqCount);
                            this.rxPromiseresolve(this.rxPromisecallback(buff));
                            this.rxPromise=null;
                        }
                    }
                }
            }, 1);
        }
        log(obj){
            this.logs.push(obj.toString());
        }
        open(){
            try{
                navigator.bluetooth.requestDevice({ filters: [{ services: [this.filters] }] })
                .then(device => {
                    this.log('Connecting...');
                    this.deviceName = device.name;
                    this.device = device;
                    device.addEventListener('gattserverdisconnected', (event) => {
                        //connectButton.textContent = '连接蓝牙设备';
                        this.OnstatusChange(this,false);
                        this.connected=false;
                    });
                    return this.device.gatt.connect();
                })
                .then(server => {
                    this.log('Getting Service...');
                    return server.getPrimaryService(this.filters);
                })
                .then(service => {
                    this.Service = service;
                    this.log('Getting Characteristic...');
                    //return service.requestMtu(250);
                    return service.getCharacteristic(this.readservice);
                })
                .then(characteristic => {
                    //myCharacteristic = characteristic;
                    return characteristic.startNotifications().then(_ => {
                        this.log('> Notifications started');
                        this.log("Connected to: " + this.deviceName);
                        characteristic.addEventListener('characteristicvaluechanged',
                            (event) => {
                                this.buffer.push(...new Uint8Array(event.target.value.buffer));
                                if(this.buffer.length>=this.rxReqCount)
                                {
                                    this.OnReceiveData(this.buffer);
                                    if(this.rxPromise){
                                        if(this.buffer.length>=this.rxReqCount){
                                            const buff=this.buffer.splice(0,this.rxReqCount);
                                            this.rxPromiseresolve(this.rxPromisecallback(buff));
                                            this.rxPromise=null;
                                        }
                                    }
                                }
                                else
                                    this.OnReceiveData(this.buffer);
                            });
                    });
                })
                .then(_ => {
                    return this.Service.getCharacteristic(this.writeservice);
                })
                .then(sender => {
                    this.log('> get Sender');
                    this.Sender = sender;
                    this.OnstatusChange(this,true);
                    this.connected=true;
                    //connectButton.textContent = '断开蓝牙设备';
                })
                .catch(error => {
                    this.log('蓝牙连接错误:' + error);
                });
            }
            catch(error){
                this.log('蓝牙连接错误:' + error);
            }
        }
        close(){
            try{
                this.device.gatt.disconnect();
            }catch(error){
                log(`error:${error.toString()}`);
            }
        }
        sendBytes(v){
            if(!this.Sender)return;
            if(this.rxFollowTx)this.rxReqCount=v.length;
            return this.Sender.writeValue(new Uint8Array(v));
        }
        waitBytes(call=()=>{},nbytes=-1){
            if(nbytes>0)this.rxReqCount=nbytes;
            if(this.rxPromise)this.rxPromisereject();
            this.rxPromise = new Promise((resolve, reject) => {
                this.rxPromiseresolve=resolve;
                this.rxPromisereject=reject;
            });
            this.rxPromisecallback=call;
            return this.rxPromise;
        }
    }
</script>
<script>

    class UARTSWDDevice{
        constructor(COM){
            this.COM=COM;
            this.data=[];
            this.Parity=0;
            this.rate=0xfc;

            this.lastInt=0;
            this.lastData=[];

            this.rcache=[];
            this.wcache=[];
            this.coreID=0;
            this.transRate=0;
            for (let i = 0; i < 46; i++) {
                this.rcache.push(255);
                this.wcache.push(255);
            }
            this.brInt=(r)=>{
                for (let i = 0; i < 8; i++) {
                    if (r & 1) this.rcache[i]=0xff;
                    else this.rcache[i]=0xf0;
                    r >>= 1;
                }
                return this.rcache;
            }
            this.rInt=(r)=>{
                return this.COM.sendBytes(this.brInt(r));
            }
            this.bwInt=(r,v)=>{
                for (let i = 0; i < 8; i++) {
                    if (r & 1) this.wcache[i]=0xff;
                    else this.wcache[i]=0xf0;
                    r >>= 1;
                }
                let addr = 0;
                for (let i = 13; i < 45; i++) {
                    if (v & 1) this.wcache[i]=0xff;
                    else this.wcache[i]=0xf0;
                    addr += v;
                    v >>>= 1;
                }
                this.wcache[45] = (addr&1) ? 0xff : 0xf0;
                return this.wcache;
            }
            this.wInt=(r,v)=>{
                return this.COM.sendBytes(this.bwInt(r,v));
            }
        }
        w8(v, data) {
            data = data ? data : this.data;
            for (let i = 0; i < 8; i++) {
                if (v & 1) data.push(255);
                else data.push(240);
                v >>= 1;
            }
        }
        w32(v, data) {
            data = data ? data : this.data;
            let addr = 0;
            for (let i = 0; i < 32; i++) {
                if (v & 1) data.push(255);
                else data.push(240);
                addr += v;
                v >>>= 1;
            }
            return addr;
        }

        rst(){
            this.COM.buffer.length=0;
            this.data.length=0;
            this.w32(0xffffffff);
            this.w32(0xffffffff);
            this.w8(0x9e);
            this.w8(0xe7);
            this.w32(0xffffffff);
            this.w32(0xffffffff);
            this.data.push(...[0xf0, 0xf0]);
            this.w8(0xa5);
            this.data.push(...[255, 255, 255]);
            this.w32(0xffffffff);
            this.data.push(...[255, 255, 255]);
            return this.COM.sendBytes(this.data)
            .then(e=>this.COM.waitBytes((b)=>(this.lastInt=this.readInt(b))));
        }

        wBus(addr,value){
            return this.wInt(addr,value)
            .then(e=>this.COM.waitBytes((b)=>(this.lastInt=this.readInt(this.lastData=b))));
        }

        rBus(addr){
            return this.rInt(addr)
            .then(e=>this.COM.waitBytes((b)=>(this.lastInt=this.readInt(this.lastData=b))));
        }

        WriteData(addr,data){
            this.data.length=0;
            this.data.push(...this.bwInt(0x8b,addr));
            this.data.push(...this.bwInt(0xbb,data));
            this.data.push(...this.brInt(0xbd));
            return this.COM.sendBytes(this.data)
            .then(e=>this.COM.waitBytes((b)=>(this.lastInt=this.readInt(this.lastData=b))));
            
            return this.wBus(0x8b,addr)
            .then(e=>this.wBus(0xbb,data))
            .then(e=>this.rBus(0xbd));
        }

        ReadData(addr){
            this.data.length=0;
            this.data.push(...this.bwInt(0x8b,addr));
            this.data.push(...this.brInt(0x9f));
            this.data.push(...this.brInt(0xbd));
            return this.COM.sendBytes(this.data)
            .then(e=>this.COM.waitBytes((b)=>(this.lastInt=this.readInt(this.lastData=b))));

            return this.wBus(0x8b,addr)
            .then(e=>this.rBus(0x9f))
            .then(e=>this.rBus(0xbd));
        }

        Go(){
            return this.WriteData(0xE000EDF0,0xA05F0001);
        }

        Halt(){
            return this.WriteData(0xE000EDF0,0xA05F0003);
        }

        isHalt(){
            return this.ReadData(0xE000EDF0)
            .then(e=>((e&0x00020000)!=0));
        }

        WriteReg(reg,value){
            return this.WriteData(0xE000EDF8,value)
            .then(e=>this.WriteData(0xE000EDF4,reg|0x10000))
        }

        ReadReg(reg){
            return this.WriteData(0xE000EDF4,reg)
            .then(e=>this.ReadData(0xE000EDF8))
        }

        connect(){
            return this.rst()
            .then(e=>{
                this.coreID=e;
                this.rate = (this.lastData[190]<252||this.lastData[189]<252) && 248 || 252;
                return this.wBus(0x81,0x1e)})
            .then(e=>this.wBus(0xb1,0))
            .then(e=>this.wBus(0xA9,0x50000000))
            .then(e=>this.rBus(0x8D))
            .then(e=>this.rBus(0x8D))
            .then(e=>this.rBus(0x8D))
            .then(e=>this.wBus(0xb1,0))
            .then(e=>this.wBus(0xa3,0x23000012))
            .then(e=>this.rBus(0x8D))
            .then(e=>this.Go())
        }

        softReset(){
            this.COM.buffer.length=0;
            return this.Halt()
            .then(e=>this.WriteData(0xE000EDFC,1))
            .then(e=>this.ReadData(0xE000EDF0))
            .then(e=>this.WriteData(0xE000ED0C,0x05fa0004))
            .then(e=>this.WriteReg(16,0x01000000))
            .then(e=>this.WriteData(0xE000EDFC,(1 << 24)))
        }

        writeMem32(addr,data){
            let r=new DataHelper(data);
            return this.wBus(0x8B,addr)
            .then(e=>{
                let len=(data.length+3)>>>2;
                let write=()=>{
                    if(r.rpos<r.data.length){
                        this.data.length=0;
                        this.data.push(...this.bwInt(0xBB,r.r32()));
                        if(r.rpos<r.data.length)this.data.push(...this.bwInt(0xBB,r.r32()));
                        if(r.rpos<r.data.length)this.data.push(...this.bwInt(0xBB,r.r32()));
                        //if(r.rpos<r.data.length)this.data.push(...this.bwInt(0xBB,r.r32()));
                        //console.log(`rpos:${r.rpos} : size:${this.data.length}`);
                        this.transRate=r.rpos/r.data.length;
                        return this.COM.sendBytes(this.data).then(_=>write());
                    }
                    return null;
                }
                return write();
            })
            .then(e=>this.rBus(0xBD))
            .then(e=>{COM.buffer.length=0;});
        }

        readMem32(addr,length){
            this.COM.buffer.length=0;
            let len=(length+3)>>>2;
            return this.wBus(0x8B,addr)
            .then(e=>this.rBus(0x9F))
            .then(e=>{
                this.COM.buffer.length=0;
                let bytes=this.brInt(0x9F);
                let count=0;
                let read=()=>{
                    if(count<len){
                        this.data.length=0;
                        this.data.push(...bytes);count++;
                        if(count<len){this.data.push(...bytes);count++;}
                        if(count<len){this.data.push(...bytes);count++;}
                        //if(count<len){this.data.push(...bytes);count++;}
                        this.transRate=count/len;
                        //console.log(`rpos:${count} : ${len}`);
                        return this.COM.sendBytes(this.data).then(_=>read());
                    }
                    return null;
                }
                return read();
            })
            .then(e=>{
                return this.COM.waitBytes((b)=>{let v=this.readInts(b,len);this.COM.buffer.length=0;return v;},len*46);
            })
        }


        async AllReg(){
            let regs=[];
            for (let i = 0; i < 21; i++) {
                let val= await this.ReadReg(i);
                regs.push(val);
            }
            return regs;
        }

        async viewregs(){
            let str=[];
            for (let i = 0; i < 17; i++) {
                let v=await this.ReadReg(i);
                if(i<13){
                    let r=`R`+i;
                    if(i<10)r+=' '
                    str.push(`${r} = 0x${Hex32(v)}\r\n`);
                }
                else{
                    switch(i){
                        case 13:str.push(`SP  = 0x${Hex32(v)}\r\n`);break;
                        case 14:str.push(`LR  = 0x${Hex32(v)}\r\n`);break;
                        case 15:str.push(`PC  = 0x${Hex32(v)}\r\n`);break;
                        case 16:str.push(`xPSR= 0x${Hex32(v)}\r\n`);break;
                    }
                }
            }
            return str.join('');
        }

        readInt(data) {
            if (data.length < 35) return;
            let index = data.length - 35;
            let value = 0;
            const r=this.rate;
            for (let i = 0; i < 32; i++) {
                value >>>= 1;
                if (data[index + i] > r) value |= 0x80000000;
            }
            return value;
        }

        readInts(data,len){
            if(data.length<46*len)return;
            let index=data.length-35;
            let vals=[];
            for (let j = 0; j < len; j++) {
                let value=0;
                for(let i=0;i<32;i++){
                    value>>>=1;
                    if(data[index+i]>this.rate)value|=0x80000000;
                }
                index-=46;
                vals.unshift(value);
            }
            return vals;
        }

    }

    function toHex(v) {
        let hex;
        if ((v & 0xf) < 10) hex = String.fromCharCode(48 + (v & 0xf));
        else hex = String.fromCharCode(65 + (v & 0xf) - 10);
        v >>>= 4;
        if ((v & 0xf) < 10) hex = String.fromCharCode(48 + (v & 0xf)) + hex;
        else hex = String.fromCharCode(65 + (v & 0xf) - 10) + hex;
        return hex;
    }
    function toHex32(v) {
        return toHex((v >>> 24) & 0xff) + toHex((v >>> 16) & 0xff) + toHex((v >>> 8) & 0xff) + toHex(v & 0xff);
    }
    function padHex(value) {
        return ('00' + value.toString(16).toUpperCase()).slice(-2);
    }
    function Hex8(value) {
        return ('0' + (value&0xff).toString(16).toUpperCase()).slice(-2);
    }
    function Hex16(value) {
        return ('000' + (value&0xffff).toString(16).toUpperCase()).slice(-4);
    }
    function Hex32(value) {
        return Hex16((value>>>16))+Hex16(value);
    }

    function u32t8(uint32){
        uint32 = Array.isArray(uint32)?new Uint32Array(uint32):uint32;
        let u8Array = new Uint8Array(uint32.length * 4);
        for (let i = 0; i < uint32.length; i++) {
            u8Array[i * 4] = uint32[i] & 0xFF;
            u8Array[i * 4 + 1] = (uint32[i] >> 8) & 0xFF;
            u8Array[i * 4 + 2] = (uint32[i] >> 16) & 0xFF;
            u8Array[i * 4 + 3] = (uint32[i] >> 24) & 0xFF;
        }
        return u8Array;
    }

    function viewhex(array,hex=true){
        let str=[];
        str.push('HEX   |')
        for (let i = 0; i < 16; i++) {
            str.push(hex && `${toHex(i&0xff)} ` || `${i.toString().padStart(2, '0')} `);
        }
        let newline=true;
        let lineindex=0;
        for (let i = 0; i < array.length; i++) {
            
            if(i%16==0){
                newline=true;
            }
            if(newline){
                newline=false;
                let it=hex && (toHex((i>>>8)&0xff)+toHex(i&0xff)) || (''+i);
                while(it.length<5)it+=' ';
                str.push(`\r\n${it} |`);
            }
            str.push(`${toHex(array[i]&0xff)} `);
        }
        return str.join('');
    }
</script>
<script>
    var bt=document.getElementById('opencom');
    var output=document.getElementById('output');
    var COM=new BLEUART((com,b)=>{
        if(b)
            bt.innerText='断开串口';
        else
            bt.innerText='打开串口';
    });
    var SWD=new UARTSWDDevice(COM);

    function openble(){
        if(COM.connected)
            COM.close();
        else
            COM.open();
    }

    async function runtime(call) {
        const startTime = performance.now();
        await call();
        const endTime = performance.now();
        const executionTime = endTime - startTime;
        output.innerText+=(`Promise executed in ${executionTime.toFixed(2)} milliseconds\r\n`);
    }

    async function testswd() {
        output.innerText='';
        await runtime(async()=>{return SWD.connect()});
        output.innerText+=`coreID:${Hex32(SWD.coreID)}\r\n`;
        await runtime(async()=>{return SWD.softReset()});
        output.innerText+=`isHalt:${Hex32(await SWD.isHalt())}\r\n`;
        await runtime(async()=>{return output.innerText+=(await SWD.viewregs())});
        output.innerText+=`write 1K Data\r\n`;
        let b=[];for(let i=0;i<1024;i++)b.push(i&0xff);
        await runtime(async()=>{return SWD.writeMem32(0x20000000,b)});
        output.innerText+=`read 1K Data\r\n`;
        await runtime(async()=>{output.innerText+=(viewhex(u32t8(await SWD.readMem32(0x20000000,1024))))+'\r\n'})
    }


</script>
</html>